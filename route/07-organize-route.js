/*
    這一節純粹就是介紹關於如何組織路由的概念.
    直到現在為止的經驗，我們知道直接把所有路由定義在主程式內不是一個很聰明的作法,隨著時間過去程式碼可能會越來越肥,
    而且無法很好的分開所有功能. 

    而實做上，Express並沒有特定要求我們應該怎樣去組織路由，因此一切都還是取決於我們,以下幾點是書中對於組織路由的一些建議.
    1. 路由處理式要使用具名函式, 像是我們前面定義handler.js內的那些函數一樣，相比於直接在處理式的位置放箭頭函式,
        這會讓路由處理式的功用更加明確，增進整體的可讀性

    2. 拿捏好需要將路由處理式分成幾類(幾個檔案) , 若說將所有路由處理式全部包在一個檔案內是一個極端,
        但這種作法在大型的(具有很多路由)的網站中就會很難找到特定路由, 而另一個極端就是將路由分成非常多類,
        但這樣也有可能是我們在更新或修正某協邏輯時, trace處理式的過程變得很辛苦.
    
    3. 路由組織的可擴充性，盡管一開始我們的網站路由可能不多,但仍然需要為將來這個網站可能的擴充做好規劃.

    4. 使用自動view-based的路由處理式來處理靜態網頁 , 這一點應用在當我們有很多的路由最終指向一個靜態網頁時,
        我們可能會使用固定的URL , 而且最終以 app.get("/static/thing" , (req,res)=> res.render('static') ') 來處理時,
        為了減少不必要的重複code , 可以使用自動化的view-based處理式,這也是本章待會要介紹的作法

    -----------------------------------------------------------
    雖然本章節沒有特定主題的程式碼實做，但書上還是簡單的示範了一下我們應該是如何組織路由,  
*/


//   下面的這個作法，即是讓我們自己將路由處理式放在一個模組內, 並讓模組回傳'該處理式method與實際處理式內容'的物件陣列.
//    然後以上面的寫法去定義路由. 而且這種寫法的另外一個好處事可以讓我們把處理式的模組也給存入Database or JSON
    const routes = require('/routes.js') ; 
    routes.forEach( route => app[route.method](route.handler) ) 

    

//    第二種作法,我們的模組回傳一個需要以app作為參數的函數 , 在函數內將我們給予的app物件進行路由的設定
//    接著再需要使用的時候, 使用require模組載入並傳入app

    module.exports = app =>{
        app.get('/',  (req,res)=> app.render('home'))
    }

    // 載入的方法一,直接把app放進去進行設定就完事了
    require('./module')(app) 

    // 載入的方法二,初始化我們的method ,再傳入
    const addRoute = require('./module') 
    addRoute(app) 



